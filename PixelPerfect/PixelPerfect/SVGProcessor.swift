import Foundation
import AppKit
import CoreImage
import UniformTypeIdentifiers
import os.log

struct SVGProcessor {
    private static let logger = Logger(subsystem: "com.pixelperfect.app", category: "SVGProcessor")
    
    // MARK: - SVG Processing Result
    struct SVGResult {
        let imageData: Data
        let image: NSImage
        let format: String
        let size: Int
        let success: Bool
    }
    
    // MARK: - Main SVG Processing Function
    static func processAsSVG(_ cgImage: CGImage, quality: Double) -> SVGResult? {
        logger.info("Starting SVG processing with quality: \(quality)")
        
        // Try multiple SVG generation approaches in order of preference
        let approaches: [(String, () -> SVGResult?)] = [
            ("Vector tracing to SVG", { tryVectorTracingSVG(cgImage, quality: quality) }),
            ("Embedded bitmap SVG", { tryEmbeddedBitmapSVG(cgImage, quality: quality) }),
            ("SVG via external tool", { tryExternalSVG(cgImage, quality: quality) })
        ]
        
        for (approachName, approach) in approaches {
            logger.info("Trying SVG approach: \(approachName)")
            if let result = approach() {
                logger.info("SVG generation successful using: \(approachName)")
                return result
            } else {
                logger.warning("SVG approach failed: \(approachName)")
            }
        }
        
        // All SVG approaches failed, return PNG fallback
        logger.error("All SVG approaches failed, falling back to PNG")
        return createPNGFallback(cgImage, quality: quality)
    }
    
    // MARK: - Approach 1: Vector Tracing SVG
    private static func tryVectorTracingSVG(_ cgImage: CGImage, quality: Double) -> SVGResult? {
        // This would implement vector tracing to convert bitmap to true SVG vectors
        // For now, we'll skip this as it's complex and would require advanced algorithms
        logger.info("Vector tracing SVG not implemented - would require complex tracing algorithms")
        return nil
    }
    
    // MARK: - Approach 2: Embedded Bitmap SVG
    private static func tryEmbeddedBitmapSVG(_ cgImage: CGImage, quality: Double) -> SVGResult? {
        logger.info("Generating SVG with embedded bitmap")
        
        // Convert CGImage to PNG data for embedding
        let bitmapRep = NSBitmapImageRep(cgImage: cgImage)
        let properties: [NSBitmapImageRep.PropertyKey: Any] = [
            .compressionFactor: quality
        ]
        
        guard let pngData = bitmapRep.representation(using: .png, properties: properties) else {
            logger.error("Failed to create PNG data for SVG embedding")
            return nil
        }
        
        let base64String = pngData.base64EncodedString()
        let width = cgImage.width
        let height = cgImage.height
        
        // Create SVG with embedded base64 PNG
        let svgContent = """
        <?xml version="1.0" encoding="UTF-8"?>
        <svg width="\(width)" height="\(height)" viewBox="0 0 \(width) \(height)" 
             xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <title>Optimized Image</title>
          <desc>Generated by PixelPerfect - Professional Image Optimization</desc>
          <image x="0" y="0" width="\(width)" height="\(height)" 
                 xlink:href="data:image/png;base64,\(base64String)"/>
        </svg>
        """
        
        guard let svgData = svgContent.data(using: .utf8) else {
            logger.error("Failed to create SVG data")
            return nil
        }
        
        // Create NSImage from SVG data
        if let image = NSImage(data: svgData) {
            return SVGResult(
                imageData: svgData,
                image: image,
                format: "SVG",
                size: svgData.count,
                success: true
            )
        }
        
        return nil
    }
    
    // MARK: - Approach 3: External SVG Tool
    private static func tryExternalSVG(_ cgImage: CGImage, quality: Double) -> SVGResult? {
        // Check if external SVG conversion tools are available
        let svgTools = [
            "/usr/local/bin/potrace",
            "/opt/homebrew/bin/potrace",
            "/usr/bin/potrace",
            "/usr/local/bin/autotrace",
            "/opt/homebrew/bin/autotrace"
        ]
        
        for toolPath in svgTools {
            if FileManager.default.fileExists(atPath: toolPath) {
                logger.info("Found SVG tool at: \(toolPath)")
                return convertUsingExternalTool(cgImage, toolPath: toolPath, quality: quality)
            }
        }
        
        logger.info("No external SVG tools found")
        return nil
    }
    
    private static func convertUsingExternalTool(_ cgImage: CGImage, toolPath: String, quality: Double) -> SVGResult? {
        // Create temporary files
        let _ = NSTemporaryDirectory()
        
        // Convert CGImage to PBM (bitmap format that potrace can handle)
        // This is a simplified approach - real implementation would need proper bitmap conversion
        logger.info("External SVG conversion not fully implemented - would require proper bitmap preprocessing")
        
        return nil
    }
    
    // MARK: - PNG Fallback
    private static func createPNGFallback(_ cgImage: CGImage, quality: Double) -> SVGResult? {
        let bitmapRep = NSBitmapImageRep(cgImage: cgImage)
        let properties: [NSBitmapImageRep.PropertyKey: Any] = [
            .compressionFactor: quality
        ]
        
        guard let data = bitmapRep.representation(using: .png, properties: properties),
              let image = NSImage(data: data) else {
            return nil
        }
        
        return SVGResult(
            imageData: data,
            image: image,
            format: "PNG (SVG generation failed)",
            size: data.count,
            success: false
        )
    }
    
    // MARK: - System SVG Support Check
    static func checkSVGSupport() -> (hasImageIOSupport: Bool, hasExternalTool: Bool, supportDetails: String) {
        // Check ImageIO support for SVG
        let supportedTypes = CGImageDestinationCopyTypeIdentifiers() as! [String]
        let svgUTIs = ["public.svg-image", "org.w3c.svg", "image/svg+xml"]
        let hasImageIOSupport = svgUTIs.contains { supportedTypes.contains($0) }
        
        // Check external tool support
        let svgTools = [
            "/usr/local/bin/potrace",
            "/opt/homebrew/bin/potrace",
            "/usr/bin/potrace",
            "/usr/local/bin/autotrace",
            "/opt/homebrew/bin/autotrace"
        ]
        let hasExternalTool = svgTools.contains { FileManager.default.fileExists(atPath: $0) }
        
        var details = "SVG Support Analysis:\n"
        details += "- ImageIO SVG support: \(hasImageIOSupport ? "Yes" : "No")\n"
        details += "- External SVG tools: \(hasExternalTool ? "Yes" : "No")\n"
        details += "- Available ImageIO types: \(supportedTypes.joined(separator: ", "))\n"
        
        if hasExternalTool {
            let availableTools = svgTools.filter { FileManager.default.fileExists(atPath: $0) }
            details += "- Available tools: \(availableTools.joined(separator: ", "))\n"
        }
        
        logger.info("\(details)")
        
        return (hasImageIOSupport, hasExternalTool, details)
    }
}
